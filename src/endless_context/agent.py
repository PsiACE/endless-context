from __future__ import annotations

import asyncio
import os
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Iterable, Literal

from bub.app.runtime import AppRuntime

from endless_context.bub_runtime import build_runtime

DEFAULT_SYSTEM_PROMPT = (
    "You are a tape-first assistant. Keep answers concise, grounded in recorded facts, "
    "and maintain continuity with handoff anchors."
)
AUTO_BOOTSTRAP_ANCHOR = "session/start"
AUTO_BOOTSTRAP_STATE = {
    "owner": "human",
}

ViewMode = Literal["full", "latest", "from-anchor"]


def _run_async(coro: Any) -> Any:
    loop = asyncio.new_event_loop()
    try:
        return loop.run_until_complete(coro)
    finally:
        loop.close()


@dataclass(frozen=True)
class AnchorState:
    entry_id: int
    name: str
    label: str
    summary: str
    facts: list[str]
    created_at: str | None


@dataclass(frozen=True)
class ConversationSnapshot:
    tape_name: str
    entries: list[Any]
    anchors: list[AnchorState]
    active_anchor: AnchorState | None
    context_entries: list[Any]
    estimated_tokens: int

    @property
    def total_entries(self) -> int:
        return len(self.entries)

    @property
    def context_entry_count(self) -> int:
        return len(self.context_entries)

    @property
    def messages(self) -> list[dict[str, str]]:
        result: list[dict[str, str]] = []
        run_step: dict[str, int] = {}
        current_step = 1
        for entry in self.entries:
            kind = getattr(entry, "kind", "")
            payload = getattr(entry, "payload", {})
            meta = getattr(entry, "meta", {})
            if not isinstance(payload, dict):
                continue
            if not isinstance(meta, dict):
                meta = {}

            if kind == "event" and payload.get("name") == "loop.step.start":
                data = payload.get("data")
                if isinstance(data, dict):
                    step = data.get("step")
                    if isinstance(step, int) and step > 0:
                        current_step = step
                continue

            if kind == "system":
                run_id = meta.get("run_id")
                if isinstance(run_id, str) and run_id:
                    run_step[run_id] = current_step
                continue

            if kind == "message":
                role = payload.get("role")
                content = payload.get("content")
                if role in {"user", "assistant"} and isinstance(content, str):
                    if role == "user":
                        run_id = meta.get("run_id")
                        if isinstance(run_id, str) and run_step.get(run_id, 1) > 1:
                            # Internal follow-up user turn generated by runtime loop.
                            continue
                    result.append({"role": role, "content": content})
                continue

            # Comma commands are persisted as events; include them in chat history
            # so refresh does not "lose" the interaction.
            if kind != "event" or payload.get("name") != "command":
                continue
            data = payload.get("data")
            if not isinstance(data, dict):
                continue
            if data.get("origin") != "human":
                continue
            raw = data.get("raw")
            output = data.get("output")
            if isinstance(raw, str) and raw.strip():
                user_msg = {"role": "user", "content": raw}
                if not result or result[-1] != user_msg:
                    result.append(user_msg)
            if isinstance(output, str) and output.strip():
                result.append({"role": "assistant", "content": output})
        return result


class BubAgent:
    """Bub-powered chat agent with Gradio-oriented snapshot helpers."""

    def __init__(
        self,
        user_id: str = "default",
        agent_id: str = "endless-context",
        tape_name: str | None = None,
        system_prompt: str = DEFAULT_SYSTEM_PROMPT,
        runtime: AppRuntime | None = None,
        session_id: str | None = None,
        workspace: Path | None = None,
    ) -> None:
        self.user_id = user_id
        self.agent_id = agent_id
        self.system_prompt = system_prompt
        self._workspace = workspace or Path(os.getenv("BUB_WORKSPACE_PATH", ".")).resolve()
        self._runtime = runtime or build_runtime(self._workspace)
        if self.system_prompt.strip():
            self._runtime.settings = self._runtime.settings.model_copy(update={"system_prompt": self.system_prompt})
        default_session = session_id or f"{agent_id}:{user_id}"
        self._session_id = tape_name or default_session
        self._session = self._runtime.get_session(self._session_id)

    @property
    def tape_name(self) -> str:
        return str(self._session.tape.tape.name)

    def reply(
        self,
        message: str,
        history: Iterable[dict[str, Any]] | None = None,
        *,
        view_mode: ViewMode = "latest",
        anchor_name: str | None = None,
    ) -> str:
        if not isinstance(message, str):
            raise ValueError("message must be a string")
        if not message.strip():
            return ""
        del history

        resolved_mode, resolved_anchor_name, entries, anchors = self._resolve_view(
            view_mode=view_mode,
            anchor_name=anchor_name,
            ensure_anchor=view_mode != "full",
        )
        _, context_entries = select_context_entries(entries, anchors, resolved_mode, resolved_anchor_name)
        self._session.tape.append_event(
            "gradio.context_selection",
            {
                "view_mode": resolved_mode,
                "anchor_name": resolved_anchor_name,
                "context_entry_count": len(context_entries),
                "estimated_tokens": estimate_tokens(context_entries),
            },
        )

        loop_result = _run_async(self._runtime.handle_input(self._session_id, message))
        if loop_result.error:
            return f"Error: {loop_result.error}"

        outputs: list[str] = []
        if loop_result.immediate_output and loop_result.immediate_output.strip():
            outputs.append(loop_result.immediate_output.strip())
        if loop_result.assistant_output and loop_result.assistant_output.strip():
            outputs.append(loop_result.assistant_output.strip())
        return "\n\n".join(outputs).strip()

    def handoff(
        self,
        name: str,
        *,
        phase: str = "",
        summary: str = "",
        facts: list[str] | None = None,
    ) -> str:
        normalized = self._normalize_anchor_name(name)
        state: dict[str, Any] = {}
        if phase.strip():
            state["phase"] = phase.strip()
        if summary.strip():
            state["summary"] = summary.strip()
        if facts:
            clean_facts = [item.strip() for item in facts if item.strip()]
            if clean_facts:
                state["facts"] = clean_facts
        self._session.tape.handoff(normalized, state=state or None)
        return normalized

    def reset(self) -> None:
        self._session.tape.append_event(
            "gradio.tape_archived",
            {
                "old_tape": self.tape_name,
                "reason": "user_reset",
            },
        )
        self._session.tape.reset(archive=True)
        self._runtime.reset_session_context(self._session_id)

    def snapshot(
        self,
        *,
        view_mode: ViewMode = "latest",
        anchor_name: str | None = None,
    ) -> ConversationSnapshot:
        resolved_mode, resolved_anchor_name, entries, anchors = self._resolve_view(
            view_mode=view_mode,
            anchor_name=anchor_name,
            ensure_anchor=view_mode != "full",
        )
        active_anchor, context_entries = select_context_entries(
            entries,
            anchors,
            resolved_mode,
            resolved_anchor_name,
        )
        return ConversationSnapshot(
            tape_name=self.tape_name,
            entries=entries,
            anchors=anchors,
            active_anchor=active_anchor,
            context_entries=context_entries,
            estimated_tokens=estimate_tokens(context_entries),
        )

    def _read_entries(self) -> list[Any]:
        return list(self._session.tape.read_entries())

    def _create_bootstrap_anchor(self) -> tuple[list[Any], list[AnchorState], AnchorState | None]:
        self._session.tape.ensure_bootstrap_anchor()
        entries = self._read_entries()
        anchors = extract_anchors(entries)
        created = find_anchor_by_name(anchors, AUTO_BOOTSTRAP_ANCHOR)
        if created is None and anchors:
            created = anchors[-1]
        return entries, anchors, created

    def _resolve_view(
        self,
        *,
        view_mode: ViewMode,
        anchor_name: str | None,
        ensure_anchor: bool,
    ) -> tuple[ViewMode, str | None, list[Any], list[AnchorState]]:
        entries = self._read_entries()
        anchors = extract_anchors(entries)

        if view_mode == "full":
            return "full", None, entries, anchors

        if view_mode == "latest":
            if not anchors and ensure_anchor:
                entries, anchors, _ = self._create_bootstrap_anchor()
            resolved_anchor_name = anchors[-1].name if anchors else None
            return "latest", resolved_anchor_name, entries, anchors

        target = find_anchor_by_name(anchors, anchor_name) if anchor_name else None
        if target is None and anchors:
            target = anchors[-1]
        if target is None and ensure_anchor:
            entries, anchors, target = self._create_bootstrap_anchor()
        resolved_anchor_name = target.name if target else None
        return "from-anchor", resolved_anchor_name, entries, anchors

    @staticmethod
    def _normalize_anchor_name(name: str) -> str:
        raw = name.strip()
        if not raw:
            raise ValueError("anchor name cannot be empty")
        if raw.startswith("handoff:") or raw.startswith("phase:") or raw.startswith("session/"):
            return raw
        safe = raw.lower().replace(" ", "-")
        return f"handoff:{safe}"


def extract_anchors(entries: list[Any]) -> list[AnchorState]:
    anchors: list[AnchorState] = []
    for entry in entries:
        if getattr(entry, "kind", "") != "anchor":
            continue
        payload = getattr(entry, "payload", {})
        if not isinstance(payload, dict):
            continue
        name = payload.get("name")
        if not isinstance(name, str):
            continue
        state = payload.get("state")
        if not isinstance(state, dict):
            state = {}
        summary = str(state.get("summary", "")).strip()
        facts_raw = state.get("facts")
        facts: list[str] = []
        if isinstance(facts_raw, list):
            facts = [str(item).strip() for item in facts_raw if str(item).strip()]
        phase = str(state.get("phase", "")).strip()
        label = phase or name
        meta = getattr(entry, "meta", {})
        created_at = None
        if isinstance(meta, dict):
            raw_created_at = meta.get("created_at")
            if isinstance(raw_created_at, str):
                created_at = raw_created_at
        anchors.append(
            AnchorState(
                entry_id=int(getattr(entry, "id", 0)),
                name=name,
                label=label,
                summary=summary,
                facts=facts,
                created_at=created_at,
            )
        )
    return anchors


def find_anchor_by_name(anchors: list[AnchorState], anchor_name: str | None) -> AnchorState | None:
    if not anchor_name:
        return None
    for anchor in anchors:
        if anchor.name == anchor_name:
            return anchor
    return None


def select_context_entries(
    entries: list[Any],
    anchors: list[AnchorState],
    view_mode: ViewMode,
    anchor_name: str | None,
) -> tuple[AnchorState | None, list[Any]]:
    if view_mode == "full":
        return None, list(entries)
    if not anchors:
        return None, list(entries)
    if view_mode == "latest":
        active_anchor = anchors[-1]
    else:
        active_anchor = find_anchor_by_name(anchors, anchor_name) or anchors[-1]
    return active_anchor, entries_after_id(entries, active_anchor.entry_id)


def entries_after_id(entries: list[Any], entry_id: int) -> list[Any]:
    return [entry for entry in entries if int(getattr(entry, "id", 0)) > entry_id]


def _extract_usage_tokens(entry: Any) -> int | None:
    if getattr(entry, "kind", "") != "event":
        return None
    payload = getattr(entry, "payload", {})
    if not isinstance(payload, dict):
        return None
    if payload.get("name") != "run":
        return None
    data = payload.get("data")
    if not isinstance(data, dict):
        return None
    usage = data.get("usage")
    if not isinstance(usage, dict):
        return None
    for key in ("input_tokens", "prompt_tokens", "total_tokens"):
        value = usage.get(key)
        if isinstance(value, int) and value > 0:
            return value
    return None


def _fallback_token_estimate_by_chars(entries: list[Any]) -> int:
    # Fallback method: estimate tokens by characters using chars/token ~= 4.
    total_chars = 0
    for entry in entries:
        payload = getattr(entry, "payload", {})
        if not isinstance(payload, dict):
            continue
        content = payload.get("content")
        if isinstance(content, str):
            total_chars += len(content)
        else:
            total_chars += len(str(payload))
    return max(1, total_chars // 4) if total_chars else 0


def estimate_tokens(entries: list[Any]) -> int:
    """Estimate context tokens with an explicit policy.

    1) Prefer provider-reported usage from latest `event(name="run")`.
    2) Fallback to deterministic char-based estimate when usage is unavailable.
    """
    for entry in reversed(entries):
        usage_tokens = _extract_usage_tokens(entry)
        if usage_tokens is not None:
            return usage_tokens
    return _fallback_token_estimate_by_chars(entries)
